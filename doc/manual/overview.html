<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
 <title>Graph::Easy - Manual - Overview</title>
 <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <meta name="MSSmartTagsPreventParsing" content="TRUE">
 <meta http-equiv="imagetoolbar" content="no">
 <link rel="stylesheet" type="text/css" href="../base.css">
 <link rel="stylesheet" type="text/css" href="manual.css">
 <!-- compliance patch for microsoft browsers -->
 <!--[if lt IE 7]><script src="/ie7/ie7-standard-p.js" type="text/javascript"></script><![endif]-->
</head>
<body bgcolor=white text=black>

<a name="top"></a>

<div class="menu">

  <p class="menu"><a class="menu" href="index.html" title="Back to the manual index">Index</a></p>
  <p style="height: 0.2em">&nbsp;</p>
  <p class="menucur"><a class="menucur" href="overview.html" title="How everything fits together">Overview</a></p>
    <p class="menuind"><a class="menuind" href="#inout" title="Input/Output and dataflow overview">Input/Output</a></p>
    <p class="menuind"><a class="menuind" href="#features" title="Supported features">Features</a></p>
  <p class="menuext"><a class="menuext" href="layouter.html" title="How the layouter works">Layouter</a></p>
  <p class="menuext"><a class="menuext" href="hinting.html" title="Generating specific layouts">Hinting</a></p>
  <p class="menuext"><a class="menuext" href="a-star.html" title="A* algorithm (pathfinding)">A*</a></p>
  <p class="menuext"><a class="menuext" href="output.html" title="Output formats and their limitations">Output</a></p>
  <p class="menuext"><a class="menuext" href="syntax.html" title="Syntax rules for the text format">Syntax</a></p>
  <p class="menuext"><a class="menuext" href="attributes.html" title="All possible attributes for graphs, nodes and edges">Attributes</a></p>
  <p class="menuext"><a class="menuext" href="benchmark.html" title="Benchmarks">Benchmarks</a></p>
  <p class="menuext"><a class="menuext" href="errors.html" title="Error codes and explanations">Errors</a></p>

</div>

<div class="right">

<h1>Graph::Easy - Manual</h1>

<h2>Overview</h2>

<div class="text">

<h3>Terminology</h3>

<p>
Here is a short list of terms that will be used throughout the following documents:
</p>

<ul>
  <li>node - a node or vertex in a graph like [ Bonn ]
  <li>edge - an edge connects two <code>nodes</code> (or one node with itself) like in [ Bonn ] -> [ Berlin ]
  <li>name - unique name of a <code>node</code> or groupp. <code>edges</code> and <code>graphs</code> do not have a name.
  <li>label - text that is displayed for <code>node</code>, <code>group</code>, <code>graph</code> or <code>edge</code>. For nodes, if not set, the node <code>name</code> will be used instead.
  <li>title - text displayed when you move the mouse over the <code>node</code>, <code>edge</code> etc.
  <li>port - each spot on a <code>node</code> where one <code>edge</code> can start or end
  <li>cell - one cell in the layout (which looks like a checker board)
  <li>path - needs to be found to connect two <code>nodes</code> in a <code>layout</code>
  <li>(edge) piece - each <code>path</code> can consist of more than one <code>cell</code> and each of these will contain on piece of the <code>edge</code>
  <li>layout - a physical representation of a graph (typical in a 2D plane)
  <li>Parser - parses graphs from a textual description and turns them into an internal representation
  <li>Layouter - lays out the <code>nodes</code> and <code>edges</code> of a graph
  <li>hinting - giving the layouter hints on how to generate a specific layout
  <li>A* - general algorithm to find a <code>path</code>
</ul>

<a name="inout">
<h3>Input and Output</h3>
</a>

<p>
Here is an overview of the data flow. Input is shown green, while direct output of Graph::Easy
is shown orange. The nodes in white are part of Graph::Easy.
<br>
Nodes in yellow show some possible output formats enabled via third-party
applications like 'dot'.
</p>

<img src="img/dataflow.png" alt="Data flow" title="Data flow">

<p>
There are currently two ways to create the internal data necessary for Graph::Easy to work with it:
</p>

<ul>
  <li>Create perl code
  <li>Write a text in the format Graph::Easy understands and use
   <a href="http://search.cpan.org/~tels/Graph-Easy/">Graph::Easy::Parser</a> to parse it
</ul>

<p>
Here is a bit of example Perl code:
</p>

<pre>
use strict;
use Graph::Easy;

my $graph = Graph::Easy->new();

$graph->add_edge('Bonn', 'Berlin');

my $edge = Graph::Easy::Edge->new( label => 'train' );
$graph->add_edge('Berlin', 'Bonn', $edge);
</pre>

<p>
And here is the corrosponding textual description:
</p>

<pre>
[ Berlin ] -- train --> [ Bonn ]
[ Bonn ] --> [ Berlin ]
</pre>

<p>
As you can see, the textual description is a bit shorter. Wether you want to convert
your input data to text and then parse it, or convert it directly with Perl
code is up to you, of course.
</p>

<p>
Likewise, once you have your data in an Graph::Easy object, you can output it in the
format you desire.
</p>

<p>
Note that the textual description format allows you a round-trip: you can feed
it to the Parser, and then generate again text from the resulting Graph::Easy object.
</p>

<h3>Storage vs. Layout</h3>

<p>
Graph::Easy did use the <a href="http://search.cpan.org/~jhi/Graph/">Graph</a> module
to internally store and manage the graph data. Since v0.25, it no longer does so, instead
it stores the nodes/edges simply as Perl hashes and then accesses them directly.
If you want to know why, please ready this <a href="benchmark.html">page</a>.
<br>
Note that the <code>Graph</code> module does <em>only</em> store a
representation of the graph, but not a particular layout.
For instance the following graph (given in the Graph::Easy syntax, more on that below):
</p>

<pre>
[ A ] -> [ C ] -> [ D ]
[ C ] -> [ E ]
</pre>

<p>
can be laid out in (probably infinitely) many ways. Here are two examples:
</p>

<img src="img/example1.png" alt="Example layout of simple graph" class="float">
<pre class="graph">
+---+     +---+     +---+
| A | --> | C | --> | D |
+---+     +---+     +---+
            |
            |
            v
          +---+
          | E |
          +---+
</pre>

<div class="clear"></div>

<h3>Layouts</h3>

<p>
To generate a specific layout, you need a module that provides this functionality.
There are some possibilities for generating a layout from a graph via Perl:
</p>

<ul>
  <li>Graph::Easy
  <li><a href="http://www.graphviz.org/">dot</a> (via graphviz)
  <li><a href="http://search.cpan.org/~pasky/Graph-Layderer/">Graph-Layderer</a>
  <li><a href="http://search.cpan.org/~thospel/Graph-Layout-Aesthetic/">Graph-Layout-Aesthetic</a>
</ul>

<p>
There might be more - when I started with Graph::Easy this were the options.
</p>

<p>
Unlike the others, Graph::Easy works on a checker-board tiled layout.
<br>
Note that the traditional way of placing the nodes <em>anywhere</em> does not enable you
to generate ASCII output, nor HTML. Well, it might be possible, but it is quite hard to
do when the edges don't run straight but all over the place :-)
</p>

<p>
That's one of the reasons for the existance of Graph::Easy. :-P
</p>

<a name="features">
<h3>Supported features</h3>
</a>

<p>
Graph::Easy support a wide array of features, below you will find an overview
of some of them.
</p>

<p>
Usually each node name is unique, there cannot be two nodes with the same name. Since it is sometimes
desired to have two nodes with the same text appearing in the layout, you can override the
text displayed with a label:
</p>

<pre>
[ Bonn ] { label: Berlin; } -> [ Berlin ]
</pre>

<p>
This will be rendered like this:
</p>

<img src="img/node_label.png" alt="Same node names" title="Same node names" class="float">
<pre class="graph">
+--------+     +--------+
| Berlin | --> | Berlin |
+--------+     +--------+
</pre>

<p class="clear">&nbsp;</p>

<p>
Most graphing packages also allow multi-edges. A multi-edge graph simply allows two edges going from the same
starting node to the same target node:
</p>

<pre>
[ Rostock ] -> [ Wismut ]
[ Rostock ] -> [ Wismut ]
</pre>

<img src="img/multi_edges.png" alt="Multi-edges" title="Multi-edges" class="float">

<pre class="graph">
  +---------------+
  |               v
+---------+     +--------+
| Rostock | --> | Wismut |
+---------+     +--------+
</pre>

<p class="clear">&nbsp;</p>

<p>
In addition to that, self-loops are usefull for state-machines and flowcharts.
A self-loop is one edge going from one node back to the same node again:
</p>

<pre class="graphtext">
[ Chemnitz ] -> [ Chemnitz ]
</pre>

<img src="img/self_loop.png" alt="Self-loop" title="Self-loop" class="float">

<pre class="graph">
  +------+
  v      |
+----------+
| Chemnitz |
+----------+
</pre>

<p class="clear">&nbsp;</p>

<p>
Another often used feature are undirected or bidirectional edges:
</p>

<pre class="graphtext">
[ Hamm ] <--> [ Leverkusen ]
[ Wismut ] -- [ Plauen ]
</pre>

<img src="img/edge_types.png" alt="Edge types undirected and bidirectional" class="float">

<pre class="graph">
+--------+      +------------+
|  Hamm  | <--> | Leverkusen |
+--------+      +------------+
+--------+      +------------+
| Wismut | ---- |   Plauen   |
+--------+      +------------+
</pre>

<p class="clear">&nbsp;</p>
</div><div class="text next">

<p>
Please continue with the chapter about the <a href="layouter.html">layouter</a>.
</p>

</div>

<div class="footer">
Page created <span class="date">2005-08-07</span> by <a href="/mail.html">Tels</a>. Last update: <span class="date">2005-12-13</span>
</div>

</div> <!-- end of right cell -->

</body>
</html>



